import cv2
import numpy as np
# import PDDTVisionToolBox as pd

# 手眼标定测试
# 根据TOB = THB @ TCH @ TOC, 即是物体在基坐标系下的位姿 = 手在基坐标系下的位姿 * 相机在末端坐标系下的位姿 * 物体在相机中的位姿
# 构造多组 THB @ TCH @ TOC, 其中THB由正向运动学计算,TOC由标定板真是坐标系进行solvepnp反算得到,因此需要明确尺度单位进行统一

# TOC求解 方法1：solvepnp反向求解
# 确定相机内参
Intrinsic = np.array([[4608.67157282660, 0, 1061.62064275155],
                      [0, 4582.91663814657, 992.016144532538],
                      [0, 0, 1]])
Distortion = np.array([-0.0909676387416293, -0.566132791303421, 0, 0])
# 构建目标实际坐标系
# solve pnp
# 分解R/T

# TOC求解 方法2：利用标定函数,直接计算旋转矢量,平移适量
# 旋转矢量
RotVec = np.array([
    [0.00649552966933944,	0.0304464183205675,	-3.12918044038515],
    [0.00310703074149356,	0.0346921160456176,	-3.12916026824556],
    [0.00256262772248684,	0.0329945546773618,	-3.12919140346204],
    [0.00734406197390581,	0.0293330587727277,-3.12926564562368],
    [0.00759574007865012,	0.0320896297012914,	-3.12917186464749],
    [0.00974855434537065,	0.0363226580516948,	-3.12906906353584],
    [0.00158585744846413,	0.0360074638881282,	-3.12902255575561],
    [-0.000477937842591747,	0.0330397146163100,	-3.12923606033082],
    [0.00636610288049528,	0.0307529650115653,	-3.12919311333260],
    [0.00832734599938959,	0.0305892041414883,	-3.12895480231993],
    [0.0122867201899454,	0.0389933251254699,	-3.12896439606283]
    # [-0.102801486556638,	0.0313705518534522,	-3.12585142648479],
    # [0.0682066041577525,	0.0357455141225112,	-3.12939257201478],
    # [0.00606536650240914,	0.0964368536946275,	-3.12856052796893]
    ])
# 平移向量
TransVec = np.array([
    [79.2772035916897,	26.3558110404886,   696.096406260541],
    [94.3786822896463,	26.3752707037054,	695.975988748488],
    [94.4019633819286,	41.3411846987467,	696.241336594818],
    [64.3285104685161,	41.3308823184679,	696.680723142791],
    [64.3693959387991,	26.1851532219697,	696.239436200814],
    [64.3286220811957,	10.9324447346183,	695.635302864699],
    [104.386093932688,	26.4098096945427,	695.779892184598],
    [104.426082253565,	51.3512073347923,	696.290926953969],
    [54.4702748262140,	51.2498995210195,	696.957811038706],
    [54.5041056824609,	26.1847746316956,	696.376891988162],
    [54.4516088037708,	0.809720543598310,	695.426395663292]
    # [118.840150373210,	26.4603555151565,	690.284673818191],
    # [52.8668654836883,	26.2908844701193,	697.893557497347],
    # [79.1856243800023,	-0.481701760465620,	695.414357533364]
                     ])
TransVec = 0.001 * TransVec
# 取旋转矩阵行数作为循环操作总数
row, col = RotVec.shape
# 循环获得旋转矩阵元胞与平移矩阵元胞
RotMatObjToCam = []
TransMatObjToCam = []
for i in range(row):
    # 旋转矩阵转换
    RotMatTemp = cv2.Rodrigues(RotVec[i, :])[0]
    RotMatObjToCam.append(RotMatTemp)
    # 平移向量转换
    TransMatObjToCam.append(TransVec[i, :].reshape((-1, 1)))
# TOC变形形成增广矩阵
RTObjToCam = []
for i in range(row):
    RTTemp = np.column_stack((RotMatObjToCam[i], TransMatObjToCam[i]))
    RTTemp = np.row_stack((RTTemp, np.array([0, 0, 0, 1])))
    RTObjToCam.append(RTTemp)
# print(RTObjToCam)

# THB求解
# 机械臂记录坐标值
PoseData = np.array(
    [
    [0.056435901671648026, -0.648932158946991, 0.7454119324684143, -1.5722118616104126, 1.5505869388580322, 3.140216112136841],
    [0.07143788039684296, -0.6489447355270386, 0.7450897097587585, -1.574751853942871, 1.5506489276885986, 3.1376912593841553],
    [0.07142584770917892, -0.6639490723609924, 0.7451090216636658, -1.5739235877990723, 1.5506383180618286, 3.138505697250366],
    [0.04143562167882919, -0.6639324426651001, 0.7457165718078613, -1.5721813440322876, 1.5506343841552734, 3.1402428150177],
    [0.04143394157290459, -0.648945152759552, 0.7457046508789062, -1.5745395421981812, 1.5506569147109985, 3.1378865242004395],
    [0.04143326357007027, -0.6339395046234131, 0.7457314729690552, -1.5727943181991577, 1.550656795501709, 3.139643907546997],
    [0.08142119646072388, -0.648941159248352, 0.7449266314506531, -1.57266366481781, 1.5506535768508911, 3.139756917953491],
    [0.0814410001039505, -0.6739289164543152, 0.7449080348014832, -1.5734807252883911, 1.5506463050842285, 3.1389567852020264],
    [0.0314415767788887, -0.6739470362663269, 0.7459039092063904, -1.574838638305664, 1.5506763458251953, 3.137603521347046],
    [0.03143127262592316, -0.648934006690979, 0.7459323406219482, -1.5717788934707642, 1.5506477355957031, 3.1406333446502686],
    [0.03143976256251335, -0.623939037322998, 0.7459224462509155, -1.574308156967163, 1.5506418943405151, 3.1381328105926514]
    # [0.05643024295568466, -0.6489296555519104, 0.7454091310501099, 1.5724118947982788, 1.5386176109313965, 0.0016535024624317884],
    # [0.05642150342464447, -0.6489347219467163, 0.7454002499580383, -1.5721659660339355, 1.5157229900360107, 3.140251874923706],
    # [0.05643871799111366, -0.6489390134811401, 0.7454169988632202, -2.617515802383423, 1.5304458141326904, 2.0945827960968018]
    ])

# 转换成增广矩阵
row, col = PoseData.shape
RotMatHandToBase = []
TransMatHandToBase = []
RTHandToBase = []
for i in range(row):
    # 旋转
    RotVec = np.array([PoseData[i, 3], PoseData[i, 4], PoseData[i, 5]])
    RotMatTemp = cv2.Rodrigues(RotVec)[0]
    RotMatHandToBase.append(RotMatTemp)
    # 平移
    TransVec = np.array([[PoseData[i, 0]], [PoseData[i, 1]], [PoseData[i, 2]]])
    TransMatHandToBase.append(TransVec)
    # 增广
    RTTemp = np.column_stack((RotMatTemp, TransVec))
    RTTemp = np.row_stack((RTTemp, np.array([0, 0, 0, 1])))
    RTHandToBase.append(RTTemp)

# TCH求解
# 利用Opencv 手眼求解
RotMatCamToHand, TransMatCamToHand = cv2.calibrateHandEye(RotMatHandToBase, TransMatHandToBase, RotMatObjToCam,
                                                          TransMatObjToCam)
RTCamToHand = np.column_stack((RotMatCamToHand, TransMatCamToHand))
RTCamToHand = np.row_stack((RTCamToHand, np.array([0, 0, 0, 1])))

# TOB验证
# 通过TOB的变化量验证TCH的正确性
for i in range(row):
    RTObjToBase = RTHandToBase[i] @ RTCamToHand @ RTObjToCam[i]
    # print(RTObjToBase)

print(RTCamToHand)
